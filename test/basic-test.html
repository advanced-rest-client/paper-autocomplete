<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">

  <script src="../node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../node_modules/@polymer/test-fixture/test-fixture.js"></script>
  <script src="../node_modules/mocha/mocha.js"></script>
  <script src="../node_modules/chai/chai.js"></script>
  <script src="../node_modules/wct-mocha/wct-mocha.js"></script>
  <script src="../node_modules/sinon/pkg/sinon.js"></script>

  <script type="module" src="../paper-autocomplete.js"></script>
</head>

<body>
  <test-fixture id="basic">
    <template>
      <paper-autocomplete></paper-autocomplete>
    </template>
  </test-fixture>

  <test-fixture id="input">
    <template>
      <paper-autocomplete id="fruitsSuggestions"></paper-autocomplete>
    </template>
  </test-fixture>

  <script type="module">
  import {afterNextRender} from '@polymer/polymer/lib/utils/render-status.js';
  function notifyInput(target) {
    let e = document.createEvent('Event');
    e.initEvent('input', true, false);
    target.dispatchEvent(e);
  }

  function wrapInput(element) {
    const input = document.createElement('input');
    element.target = input;
    return input;
  }

  suite('basic', function() {
    let suggestions;

    setup(function() {
      suggestions = fixture('basic');
    });

    test('`target` should be undefined', function() {
      assert.equal(suggestions.target, undefined, 'editor.target equals undefined');
    });

    test('`source` should be undefined', function() {
      assert.equal(suggestions.source, undefined, 'editor.source equals undefined');
    });
  });

  suite('input', function() {
    let suggestions;

    setup(function() {
      suggestions = fixture('input');
    });

    test('Should query on input change', function() {
      const input = wrapInput(suggestions);
      input.value = 'test';
      notifyInput(input);
      assert.equal(input.value, suggestions._previousQuery,
        'editor.value equals suggestions._previousQuery');
    });

    test('Should fire query event', function(done) {
      let word = 'TEST';
      let clb = function(e) {
        suggestions.removeEventListener('parsed', clb);
        let query = e.detail.value;
        assert.equal(word, query,
          'word equals query');
        done();
      };
      const input = wrapInput(suggestions);
      input.value = word;
      suggestions.addEventListener('query', clb);
      notifyInput(input);
    });

    test('Should filter suggestions', function(done) {
      let word = 'TEST';
      let clb = function() {
        suggestions.removeEventListener('query', clb);
        suggestions.source = [word, word + '2', 'etra73hxis'];
        setTimeout(function() {
          assert.equal(suggestions.suggestions.length, 2,
            'suggestions.suggestions.length equals 2');
          assert.equal(suggestions.opened, true,
            'suggestions.opened equals true');
          done();
        }, 1);
      };
      const input = wrapInput(suggestions);
      input.value = word;
      suggestions.addEventListener('query', clb);
      notifyInput(input);
    });
  });

  suite('suggestions', function() {
    let suggestions;
    let input;
    const source = ['Apple', 'Appli', 'Applo'];

    setup(function(done) {
      suggestions = fixture('input');
      suggestions.source = source;
      input = wrapInput(suggestions);
      setTimeout(done, 1);
    });

    test('Should compute suggestions list', function() {
      input.value = 'App';
      notifyInput(input);
      assert.equal(suggestions.suggestions.length, 3);
    });

    test('Should select first item on start.', function(done) {
      let repeater = suggestions.shadowRoot.querySelector('#repeater');
      let selector = suggestions.shadowRoot.querySelector('#selector');
      input.value = 'App';
      notifyInput(input);
      setTimeout(function() {
        let value = repeater.itemForElement(selector.selectedItem);
        assert.equal(value, source[0]);
        done();
      }, 100);
    });

    test('Should select `next` suggestion.', function(done) {
      let repeater = suggestions.shadowRoot.querySelector('#repeater');
      let selector = suggestions.shadowRoot.querySelector('#selector');
      input.value = 'App';
      notifyInput(input);
      setTimeout(function() {
        suggestions.selectNext();
        let value = repeater.itemForElement(selector.selectedItem);
        assert.equal(value, source[1]);
        done();
      }, 100);
    });

    test('Should select `previous` suggestion.', function(done) {
      let repeater = suggestions.shadowRoot.querySelector('#repeater');
      let selector = suggestions.shadowRoot.querySelector('#selector');
      input.value = 'App';
      notifyInput(input);
      setTimeout(function() {
        suggestions.selectPrevious();
        let value = repeater.itemForElement(selector.selectedItem);
        assert.equal(value, source[2]);
        done();
      }, 100);
    });

    test('Should fire `selected` event.', function(done) {
      let clb = function() {
        suggestions.removeEventListener('selected', clb);
        done();
      };

      input.value = 'App';
      suggestions.addEventListener('selected', clb);
      notifyInput(input);
      setTimeout(function() {
        suggestions.acceptSelection();
      }, 100);
    });

    test('Should update the input field.', function(done) {
      let clb = function() {
        suggestions.removeEventListener('selected', clb);
        setTimeout(function() {
          assert.equal(input.value, 'Apple');
          done();
        }, 1);
      };

      input.value = 'App';
      suggestions.addEventListener('selected', clb);
      notifyInput(input);
      setTimeout(function() {
        suggestions.acceptSelection();
      }, 100);
    });

    test('Should not update the input field.', function(done) {
      let clb = function(e) {
        e.preventDefault();
        suggestions.removeEventListener('selected', clb);

        setTimeout(function() {
          assert.equal(input.value, 'App');
          done();
        }, 1);
      };

      input.value = 'App';
      suggestions.addEventListener('selected', clb);
      notifyInput(input);
      setTimeout(function() {
        suggestions.acceptSelection();
      }, 100);
    });
  });

  suite('_valueChanged()', () => {
    let element;
    setup(function(done) {
      element = fixture('basic');
      flush(() => done());
    });

    test('Does nothing when not attached', () => {
      element.isAttached = false;
      const spy = sinon.spy(element, '_filterSuggestions');
      element._valueChanged();
      assert.isFalse(spy.called);
    });

    test('Does nothing when event target not set', () => {
      element._oldTarget = undefined;
      const spy = sinon.spy(element, '_filterSuggestions');
      element._valueChanged();
      assert.isFalse(spy.called);
    });

    test('Does nothing when no value and no previous query set', () => {
      element._oldTarget = undefined;
      const spy = sinon.spy(element, '_filterSuggestions');
      element._valueChanged();
      assert.isFalse(spy.called);
    });

    test('Calls _disaptchQuery() when no previous query', () => {
      const input = wrapInput(element);
      input.value = 'test';
      element._previousQuery = undefined;
      const spy = sinon.spy(element, '_disaptchQuery');
      element._valueChanged();
      assert.isTrue(spy.called);
    });

    test('Sets "_previousQuery"', () => {
      const input = wrapInput(element);
      input.value = 'test';
      element._previousQuery = undefined;
      element._valueChanged();
      assert.equal(element._previousQuery, 'test');
    });

    test('Sets "selectedItem"', () => {
      const input = wrapInput(element);
      input.value = 'test';
      element._previousQuery = undefined;
      element.selectedItem = undefined;
      element._valueChanged();
      assert.equal(element.selectedItem, 0);
    });

    test('Keeps old "selectedItem" when opened', () => {
      const input = wrapInput(element);
      input.value = 'test';
      element._previousQuery = undefined;
      element.selectedItem = 1;
      element.opened = true;
      element._valueChanged();
      assert.equal(element.selectedItem, 1);
    });

    test('Calls _filterSuggestions()', () => {
      const input = wrapInput(element);
      input.value = 'test';
      element._previousQuery = undefined;
      const spy = sinon.spy(element, '_filterSuggestions');
      element._valueChanged();
      assert.isTrue(spy.called);
    });

    test('Reuses data from previous query', () => {
      const input = wrapInput(element);
      input.value = 'test';
      element._previousQuery = 'tes';
      const filterSpy = sinon.spy(element, '_filterSuggestions');
      const querySpy = sinon.spy(element, '_disaptchQuery');
      element._valueChanged();
      assert.isTrue(filterSpy.called, 'Filter suggestions is called');
      assert.isFalse(querySpy.called, '_disaptchQuery() is not called');
      assert.equal(element._previousQuery, 'test', '_previousQuery is set');
    });

    test('Resets the query if input is different than the last one', () => {
      const input = wrapInput(element);
      input.value = 'other';
      element._previousQuery = 'test';
      const filterSpy = sinon.spy(element, '_filterSuggestions');
      const querySpy = sinon.spy(element, '_disaptchQuery');
      element._valueChanged();
      assert.isTrue(filterSpy.called, 'Filter suggestions is called');
      assert.isTrue(querySpy.called, '_disaptchQuery() is called');
      assert.equal(element._previousQuery, 'other', '_previousQuery is set');
    });
  });

  suite('_disaptchQuery()', () => {
    let element;
    setup(function() {
      element = fixture('basic');
    });

    test('Dispatches the event', () => {
      const spy = sinon.spy();
      element.addEventListener('query', spy);
      element._disaptchQuery('test');
      assert.isTrue(spy.called);
    });

    test('Returns the event', () => {
      const e = element._disaptchQuery('test');
      assert.typeOf(e, 'customevent');
    });

    test('Event does not bubble', () => {
      const e = element._disaptchQuery('test');
      assert.isFalse(e.bubbles);
    });

    test('Event is not cancelable', () => {
      const e = element._disaptchQuery('test');
      assert.isFalse(e.cancelable);
    });

    test('Event has value on the detail', () => {
      const e = element._disaptchQuery('test');
      assert.equal(e.detail.value, 'test');
    });
  });

  suite('_filterSuggestions()', () => {
    let element;
    setup(function(done) {
      element = fixture('basic');
      flush(() => done());
    });

    test('Does nothing when not attached', () => {
      element.isAttached = false;
      const spy = sinon.spy(element, '_setSuggestions');
      element._filterSuggestions();
      assert.isFalse(spy.called);
    });

    test('Does nothing when event target not set', () => {
      element._oldTarget = undefined;
      const spy = sinon.spy(element, '_setSuggestions');
      element._filterSuggestions();
      assert.isFalse(spy.called);
    });

    test('Does nothing when no value and no previous query set', () => {
      element._oldTarget = undefined;
      const spy = sinon.spy(element, '_setSuggestions');
      element._filterSuggestions();
      assert.isFalse(spy.called);
    });

    test('Filters out string values', () => {
      element.source = ['a', 'aa', 'b', 'ab'];
      element._previousQuery = 'a';
      wrapInput(element);
      element._filterSuggestions();
      assert.typeOf(element.suggestions, 'array');
      assert.deepEqual(element.suggestions, ['a', 'aa', 'ab']);
    });

    test('Filters out string values - cap query', () => {
      element.source = ['a', 'aa', 'b', 'ab'];
      element._previousQuery = 'A';
      wrapInput(element);
      element._filterSuggestions();
      assert.typeOf(element.suggestions, 'array');
      assert.deepEqual(element.suggestions, ['a', 'aa', 'ab']);
    });

    test('Filters out string values - cap items', () => {
      element.source = ['A', 'Aa', 'b', 'Ab'];
      element._previousQuery = 'a';
      element._filterSuggestions();
      wrapInput(element);
      assert.typeOf(element.suggestions, 'array');
      assert.deepEqual(element.suggestions, ['A', 'Aa', 'Ab']);
    });

    test('Filters out object values', () => {
      element.source = [{value: 'a'}, {value: 'aa'}, {value: 'b'}, {value: 'ab'}];
      element._previousQuery = 'a';
      wrapInput(element);
      element._filterSuggestions();
      assert.typeOf(element.suggestions, 'array');
      assert.deepEqual(element.suggestions, [{value: 'a'}, {value: 'aa'}, {value: 'ab'}]);
    });

    test('Filters out object values - cap query', () => {
      element.source = [{value: 'a'}, {value: 'aa'}, {value: 'b'}, {value: 'ab'}];
      element._previousQuery = 'A';
      wrapInput(element);
      element._filterSuggestions();
      assert.typeOf(element.suggestions, 'array');
      assert.deepEqual(element.suggestions, [{value: 'a'}, {value: 'aa'}, {value: 'ab'}]);
    });

    test('Filters out object values - cap items', () => {
      element.source = [{value: 'A'}, {value: 'Aa'}, {value: 'b'}, {value: 'Ab'}];
      element._previousQuery = 'a';
      wrapInput(element);
      element._filterSuggestions();
      assert.typeOf(element.suggestions, 'array');
      assert.deepEqual(element.suggestions, [{value: 'A'}, {value: 'Aa'}, {value: 'Ab'}]);
    });

    test('Returns all when no query', () => {
      element.source = [{value: 'a'}, {value: 'aa'}, {value: 'b'}, {value: 'ab'}];
      element._previousQuery = '';
      wrapInput(element);
      element._filterSuggestions();
      assert.typeOf(element.suggestions, 'array');
      assert.deepEqual(element.suggestions, element.source);
    });

    test('Closes element when no items after filtered', () => {
      element.source = [{value: 'a'}, {value: 'aa'}];
      element._previousQuery = 'b';
      element.opened = true;
      wrapInput(element);
      element._filterSuggestions();
      assert.isFalse(element.opened);
    });

    test('Sorts the results #1', () => {
      element.source = [{value: 'zoab'}, {value: 'saab'}, {value: 'ab'}, {value: 'Ab'}];
      element._previousQuery = 'ab';
      wrapInput(element);
      element._filterSuggestions();
      assert.deepEqual(element.suggestions, [{value: 'ab'}, {value: 'Ab'}, {value: 'saab'}, {value: 'zoab'}]);
    });

    test('Sorts the results #2', () => {
      element.source = [{value: 'xab'}, {value: 'xxab'}, {value: 'abxx'}];
      element._previousQuery = 'ab';
      wrapInput(element);
      element._filterSuggestions();
      assert.deepEqual(element.suggestions, [{value: 'abxx'}, {value: 'xab'}, {value: 'xxab'}]);
    });

    test('Sorts the results #3', () => {
      element.source = [{value: 'xxxab'}, {value: 'ab'}];
      element._previousQuery = 'ab';
      wrapInput(element);
      element._filterSuggestions();
      assert.deepEqual(element.suggestions, [{value: 'ab'}, {value: 'xxxab'}]);
    });

    test('Calls _ensureSelection()', () => {
      element.source = [{value: 'a'}, {value: 'aa'}];
      element._previousQuery = 'a';
      const spy = sinon.spy(element, '_ensureSelection');
      wrapInput(element);
      element._filterSuggestions();
      assert.isTrue(spy.called);
    });

    test('Opens the overlay', () => {
      element.source = [{value: 'a'}, {value: 'aa'}];
      element._previousQuery = 'a';
      wrapInput(element);
      element._filterSuggestions();
      assert.isTrue(element.opened);
    });
  });

  suite('selectPrevious()', () => {
    let element;
    const source = ['Apple', 'Appli', 'Applo'];

    setup(function(done) {
      element = fixture('basic');
      element.source = source;
      wrapInput(element);
      element.opened = true;
      element._setSuggestions(source);
      flush(() => done());
    });

    test('Selectes previous element', () => {
      element.selectedItem = 1;
      element.selectPrevious();
      assert.equal(element.selectedItem, 0);
    });

    test('Opens the overlay', () => {
      element.opened = false;
      element.selectedItem = 1;
      element.selectPrevious();
      assert.isTrue(element.opened);
    });

    test('Does nothing when no suggestions', () => {
      element._setSuggestions([]);
      element.opened = false;
      element.selectedItem = 1;
      element.selectPrevious();
      assert.isFalse(element.opened);
    });

    test('Goes to the end of the list', () => {
      element.selectedItem = 0;
      element.selectPrevious();
      assert.equal(element.selectedItem, 2);
    });

    test('Calls ensureItemVisible()', () => {
      const spy = sinon.spy(element, 'ensureItemVisible');
      element.selectedItem = 1;
      element.selectPrevious();
      assert.isTrue(spy.called);
    });
  });

  suite('selectNext()', () => {
    let element;
    const source = ['Apple', 'Appli', 'Applo'];

    setup(function(done) {
      element = fixture('basic');
      element.source = source;
      wrapInput(element);
      element.opened = true;
      element._setSuggestions(source);
      flush(() => done());
    });

    test('Selectes previous element', () => {
      element.selectedItem = 1;
      element.selectNext();
      assert.equal(element.selectedItem, 2);
    });

    test('Opens the overlay', () => {
      element.opened = false;
      element.selectedItem = 1;
      element.selectNext();
      assert.isTrue(element.opened);
    });

    test('Does nothing when no suggestions', () => {
      element._setSuggestions([]);
      element.opened = false;
      element.selectedItem = 1;
      element.selectNext();
      assert.isFalse(element.opened);
    });

    test('Goes to the start of the list', () => {
      element.selectedItem = 2;
      element.selectNext();
      assert.equal(element.selectedItem, 0);
    });

    test('Calls ensureItemVisible()', () => {
      const spy = sinon.spy(element, 'ensureItemVisible');
      element.selectedItem = 1;
      element.selectNext();
      assert.isTrue(spy.called);
    });
  });

  suite('_targetFocus()', () => {
    let element;
    const source = ['Apple', 'Appli', 'Applo'];

    setup(function(done) {
      element = fixture('basic');
      element.source = source;
      wrapInput(element);
      element._setSuggestions(source);
      element.openOnFocus = true;
      flush(() => done());
    });

    test('Does nothing when openOnFocus is not set', () => {
      element.openOnFocus = false;
      element._targetFocus();
      assert.isUndefined(element.__autocompleteFocus);
    });

    test('Does nothing when opened', () => {
      element.opened = true;
      element._targetFocus();
      assert.isUndefined(element.__autocompleteFocus);
    });

    test('Does nothing when __autocompleteFocus is already set', () => {
      element.__autocompleteFocus = 1;
      element._targetFocus();
      assert.equal(element.__autocompleteFocus, 1);
    });

    test('Sets __autocompleteFocus', (done) => {
      element._targetFocus();
      assert.isTrue(element.__autocompleteFocus);
      afterNextRender(element, () => {
        done();
      });
    });

    test('Sets __autocompleteFocus for debouncer', (done) => {
      element._targetFocus();
      assert.isTrue(element.__autocompleteFocus);
      afterNextRender(element, () => {
        done();
      });
    });

    test('Re-sets __autocompleteFocus', (done) => {
      element._targetFocus();
      afterNextRender(element, () => {
        assert.isFalse(element.__autocompleteFocus);
        done();
      });
    });

    test('Calls _valueChanged()', (done) => {
      element._targetFocus();
      const spy = sinon.spy(element, '_valueChanged');
      afterNextRender(element, () => {
        assert.isTrue(spy.called);
        done();
      });
    });
  });
  </script>
</body>
</html>
